\documentclass[a4paper,11pt]{article}

% Korean language support
% \usepackage{kotex}

% Fullpage layout (minimal margins)
\usepackage{fullpage}

% Minted package for code highlighting
% \usepackage{minted}

% Other useful packages
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}

% Document metadata
\title{LLM-as-a-Judge for Parser Error Clarity: A Controlled Study with Obfuscated Inputs}
\author{Ki Yung Ahn}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Abstract here
\end{abstract}

\section{Introduction}

We have good qualitative understanding why top-down parsers
tend to produce clearer error messages than bottom-up parsers.
Quantitative analysis on this aspect, however, has been limited
due to the difficulty of performing controlled studies.
Human survey tends to be costly and time-consuming.
More crucially, it is extremely difficult to select
appropriate participants for the purpose of the study.
Mashup of beginning programmers and expert programmers
would likely lead to noisy results. Even if we can select participants
with similar years of programming experience, there could be bias from
the different exposure to the specific programming language syntax
and compiler implementations.

In this work, we propose to use LLM-as-a-judge approach to perform a controlled study.
Using LLMs clearly reduces the cost and time. More importantly,
we can ensure that the judge has uniform experience on every experiment.
However, there could still be bias from the exposure to
existing programming language syntax and compiler implementations.
To mitigate this bias, we propose to use obfuscated inputs, replacing
the terminal symbols in the grammar with arbitrary symbols, while
keeping the grammar structure intact.

Why LLMs are suitable for this task?
LLMs are desinged to process and produce text, which is a sequence of tokens.
Code a sninppet and an error message along with instructions to output
the corrected code snippet, where the syntax error is fixed.

\section{Background}
Top-down parsers are known to be better at producing clearer error messages
compared to bottom-up parsers \cite{AhoSethiUllman2006}.
Qualitative explanations for why it is easier for
top-down parsers to produce clearer error messages include
\begin{itemize}
    \item earlier detection of errors due to predictive nature of top-down parsers where unexpected next input token immediately raises an error, in contrast to bottom-up parsers that may need a lot more input to decide whether parsing could continue or not,
    \item easier to associate the error with the relevant grammar rule in top-down parsers, in contrast to table-driven bottom-up parsers where the error may arise from a combination of multiple reductions and shifts internal parsing states.
\end{itemize}



\section{Main Body}
Write the main body here.

\subsection{Code Example}

This is an example of code highlighting using the minted package:
\begin{verbatim}
def hello_world():
    print("Hello, world!")
    
if __name__ == "__main__":
    hello_world()
\end{verbatim}

\section{Conclusion}

Write the conclusion here.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
